##########################################
#                                        #
#  USESTATE: RETURN VALUE VS FUNCTIONAL  #
#                                        #
##########################################

Quando usiamo useState, otteniamo due cose:

    - Il valore dello stato

    - Una funzione setter (setQualcosa) per aggiornarlo
    
    const [count, setCount] = useState(0);


La funzione setCount serve per aggiornare lo stato e forzare il re-render del componente. Una variabile normale, invece, non aggiorna il rendering.

Due modi per aggiornare lo stato:

    - Passando direttamente il nuovo valore:
    
        - setCount(count + 1);


Qui React usa il valore di count così com’è in quel momento.

    - Usando il functional update (ritorno di funzione):
        
        - setCount(prev => prev + 1);


In questo caso React prende sempre il valore più aggiornato e evita problemi con aggiornamenti asincroni

Sembrano uguali, ma NON lo sono

In condizioni normali entrambi funzionano:

<button onClick={() => setCount(count + 1)}>Aumenta</button>
<button onClick={() => setCount(prev => prev - 1)}>Diminuisci</button>


Ma la differenza emerge quando ci sono ritardi, aggiornamenti più rapidi, o operazioni asincrone:

Problema con valore diretto (es. setTimeout):

    setTimeout(() => {
    setCount(count + 1);
    }, 2000);

Se clicchi molte volte velocemente, React:

    - usa un valore “vecchio”
    - perde alcuni aggiornamenti

Soluzione: functional update

    setTimeout(() => {
    setCount(prev => prev + 1);
    }, 2000);

setState(valore) → semplice ma rischioso in asincrono

setState(prev => nuovoValore) → più sicuro e consigliato

Per questo motivo, il functional update è la pratica migliore

################
#              #
#  USEEFFECT   #
#              #
################

useEffect è un Hook che permette di gestire effetti collaterali, cioè operazioni che avvengono al di fuori del rendering del componente 
(es. chiamate API, timer, listener, log, ecc.).

Di default, useEffect viene eseguito dopo ogni render del componente.
React però ci permette di controllare quando eseguire l’effetto tramite il secondo parametro opzionale, che è un array di dipendenze.

Se l’array è vuoto ([]), useEffect viene eseguito una sola volta, subito dopo il primo render del componente.

Se nell’array inseriamo una o più variabili di stato o props, useEffect verrà eseguito solo quando uno di quei valori cambia.

È possibile e normale avere più useEffect all’interno dello stesso componente.
Ogni useEffect è indipendente e può essere responsabile di una specifica logica:
ad esempio uno può reagire alla variazione di un valore, mentre un altro può essere eseguito a ogni render.

In uno scenario reale potremmo avere:

    - uno useEffect che si attiva solo quando cambia un determinato valore,
    - uno useEffect che viene eseguito sempre,
    - uno useEffect che viene eseguito solo al primo render.

React esegue ciascun useEffect in base alle proprie dipendenze, garantendo un comportamento prevedibile e controllato.

Un aspetto fondamentale di useEffect è la cleanup function. useEffect può infatti restituire una funzione che viene eseguita:

prima della successiva esecuzione dello stesso effect oppure quando il componente viene smontato

La cleanup function è indispensabile per ripulire risorse, come:

    - event listener
    - timer

Ad esempio, se all’interno di uno useEffect aggiungiamo un event listener, è fondamentale rimuoverlo nella cleanup function.
Senza questa operazione, ad ogni aggiornamento del componente verrebbero aggiunti nuovi listener, causando problemi di performance e comportamenti indesiderati.

Grazie alla cleanup function possiamo assicurarci che:
    
    - l’event listener precedente venga rimosso
    - Ne esista sempre uno solo attivo
    - In applicazioni complesse, dove più componenti possono agganciare eventi o risorse esterne, 

l’uso corretto della cleanup function è una buona pratica fondamentale, perché garantisce controllo, stabilità e prestazioni ottimali dell’applicazione.

####################
#                  #
#  DATA FETCHING   #
#                  #
####################

Per recuperare dati da una sorgente esterna in React si utilizza spesso useEffect, insieme a strumenti come fetch o axios.
L’idea è eseguire la richiesta dati dopo il render del componente e salvare il risultato in uno stato (ad esempio photos), 
così da aggiornare automaticamente l’interfaccia quando i dati arrivano.

Poiché useEffect non può essere dichiarato async, la richiesta asincrona viene gestita tramite una funzione separata (async), 
che viene poi richiamata all’interno dello useEffect.
In questo modo si mantiene la struttura corretta dell’hook e si evita un uso scorretto di async/await direttamente in useEffect.

Questo approccio permette di:

    - caricare dati al montaggio del componente
    - evitare richieste ripetute non necessarie
    - mantenere il codice ordinato e leggibile
    - gestire correttamente il ciclo di vita del componente
